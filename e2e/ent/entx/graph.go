// Code generated by entx, DO NOT EDIT.

package entx

import (
  "fmt"
  "reflect"
  
  "entgo.io/ent/dialect/sql/sqlgraph"
  "entgo.io/ent/dialect/sql"
  "github.com/brice-74/entx"

  "e2e/ent"
  "e2e/ent/article"
  "e2e/ent/articletag"
  "e2e/ent/comment"
  "e2e/ent/department"
  "e2e/ent/employee"
  "e2e/ent/tag"
  "e2e/ent/user"
)

type ArticleNode struct {
	entx.BaseNode
}

func newArticleNode() *ArticleNode {
  cols := map[string]*entx.Field{
    "user_id": {Name:"user_id", StorageName:"user_id"},
    "title": {Name:"title", StorageName:"title"},
    "content": {Name:"content", StorageName:"content"},
    "published": {Name:"published", StorageName:"published"},
    "created_at": {Name:"created_at", StorageName:"created_at"},
    "id": {Name:"id", StorageName:"id"},
  }
  pks := []*entx.Field{
    cols["id"],
  }
	return &ArticleNode{BaseNode: entx.NewBaseNode(
    "Article",
    "articles",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *ArticleNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *ArticleNode) Policy() ent.Policy {
  return nil
}

type ArticleTagNode struct {
	entx.BaseNode
}

func newArticleTagNode() *ArticleTagNode {
  cols := map[string]*entx.Field{
    "tag_id": {Name:"tag_id", StorageName:"tag_id"},
    "article_id": {Name:"article_id", StorageName:"article_id"},
  }
  pks := []*entx.Field{
    cols["tag_id"],
    cols["article_id"],
  }
	return &ArticleTagNode{BaseNode: entx.NewBaseNode(
    "ArticleTag",
    "article_tags",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *ArticleTagNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *ArticleTagNode) Policy() ent.Policy {
  return nil
}

type CommentNode struct {
	entx.BaseNode
}

func newCommentNode() *CommentNode {
  cols := map[string]*entx.Field{
    "body": {Name:"body", StorageName:"body"},
    "created_at": {Name:"created_at", StorageName:"created_at"},
    "user_id": {Name:"user_id", StorageName:"user_id"},
    "article_id": {Name:"article_id", StorageName:"article_id"},
    "id": {Name:"id", StorageName:"id"},
  }
  pks := []*entx.Field{
    cols["id"],
  }
	return &CommentNode{BaseNode: entx.NewBaseNode(
    "Comment",
    "comments",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *CommentNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *CommentNode) Policy() ent.Policy {
  return nil
}

type DepartmentNode struct {
	entx.BaseNode
}

func newDepartmentNode() *DepartmentNode {
  cols := map[string]*entx.Field{
    "name": {Name:"name", StorageName:"name"},
    "id": {Name:"id", StorageName:"id"},
  }
  pks := []*entx.Field{
    cols["id"],
  }
	return &DepartmentNode{BaseNode: entx.NewBaseNode(
    "Department",
    "departments",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *DepartmentNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *DepartmentNode) Policy() ent.Policy {
  return nil
}

type EmployeeNode struct {
	entx.BaseNode
}

func newEmployeeNode() *EmployeeNode {
  cols := map[string]*entx.Field{
    "hire_date": {Name:"hire_date", StorageName:"hire_date"},
    "manager_id": {Name:"manager_id", StorageName:"manager_id"},
    "user_id": {Name:"user_id", StorageName:"user_id"},
    "department_id": {Name:"department_id", StorageName:"department_id"},
    "id": {Name:"id", StorageName:"id"},
  }
  pks := []*entx.Field{
    cols["id"],
  }
	return &EmployeeNode{BaseNode: entx.NewBaseNode(
    "Employee",
    "employees",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *EmployeeNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *EmployeeNode) Policy() ent.Policy {
  return nil
}

type TagNode struct {
	entx.BaseNode
}

func newTagNode() *TagNode {
  cols := map[string]*entx.Field{
    "name": {Name:"name", StorageName:"name"},
    "id": {Name:"id", StorageName:"id"},
  }
  pks := []*entx.Field{
    cols["id"],
  }
	return &TagNode{BaseNode: entx.NewBaseNode(
    "Tag",
    "tags",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *TagNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *TagNode) Policy() ent.Policy {
  return nil
}

type UserNode struct {
	entx.BaseNode
}

func newUserNode() *UserNode {
  cols := map[string]*entx.Field{
    "name": {Name:"name", StorageName:"name"},
    "email": {Name:"email", StorageName:"email"},
    "age": {Name:"age", StorageName:"age"},
    "is_active": {Name:"is_active", StorageName:"is_active"},
    "created_at": {Name:"created_at", StorageName:"created_at"},
    "updated_at": {Name:"updated_at", StorageName:"updated_at"},
    "id": {Name:"id", StorageName:"id"},
  }
  pks := []*entx.Field{
    cols["id"],
  }
	return &UserNode{BaseNode: entx.NewBaseNode(
    "User",
    "users",
		make(map[string]entx.Bridge),
		cols,
		pks,
  )}
}

func (n *UserNode) NewQuery(c entx.Client) entx.Query {
	return c.MustGetEntityClient(n).Query()
}

func (n *UserNode) Policy() ent.Policy {
  return nil
}
// ArticleCommentsBridge (O2M) left=Article, right=Comment
type ArticleCommentsBridge struct {
  entx.BaseBridge
}

func newArticleCommentsBridge(
  left entx.Node, right entx.Node,
) *ArticleCommentsBridge {
  return &ArticleCommentsBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "article_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*ArticleCommentsBridge) Filter() func(*sql.Selector) {
  return article.HasComments()
}

func (*ArticleCommentsBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return article.HasCommentsWith(entx.CombinePredicates(predicates...))
}

func (b *ArticleCommentsBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*ArticleQuery)
	if !ok {
		panic(fmt.Sprintf("ArticleCommentsBridge.Include expect *ArticleQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.ArticleQuery.WithComments(func(q *ent.CommentQuery) {
		cq(&CommentQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Comment](handlers...))})
	})
	return adapter
}
// CommentArticleBridge (M2O) left=Comment, right=Article
type CommentArticleBridge struct {
  entx.BaseBridge
}

func newCommentArticleBridge(
  left entx.Node, right entx.Node,
) *CommentArticleBridge {
  return &CommentArticleBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "article_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*CommentArticleBridge) Filter() func(*sql.Selector) {
  return comment.HasArticle()
}

func (*CommentArticleBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return comment.HasArticleWith(entx.CombinePredicates(predicates...))
}

func (b *CommentArticleBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*CommentQuery)
	if !ok {
		panic(fmt.Sprintf("CommentArticleBridge.Include expect *CommentQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.CommentQuery.WithArticle(func(q *ent.ArticleQuery) {
		cq(&ArticleQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Article](handlers...))})
	})
	return adapter
}
// ArticleArticleTagBridge (O2M) left=Article, right=ArticleTag
type ArticleArticleTagBridge struct {
  entx.BaseBridge
}

func newArticleArticleTagBridge(
  left entx.Node, right entx.Node,
) *ArticleArticleTagBridge {
  return &ArticleArticleTagBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "article_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*ArticleArticleTagBridge) Filter() func(*sql.Selector) {
  return article.HasArticleTag()
}

func (*ArticleArticleTagBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return article.HasArticleTagWith(entx.CombinePredicates(predicates...))
}

func (b *ArticleArticleTagBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*ArticleQuery)
	if !ok {
		panic(fmt.Sprintf("ArticleArticleTagBridge.Include expect *ArticleQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.ArticleQuery.WithArticleTag(func(q *ent.ArticleTagQuery) {
		cq(&ArticleTagQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.ArticleTag](handlers...))})
	})
	return adapter
}
// ArticleTagArticleBridge (M2O) left=ArticleTag, right=Article
type ArticleTagArticleBridge struct {
  entx.BaseBridge
}

func newArticleTagArticleBridge(
  left entx.Node, right entx.Node,
) *ArticleTagArticleBridge {
  return &ArticleTagArticleBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "article_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*ArticleTagArticleBridge) Filter() func(*sql.Selector) {
  return articletag.HasArticle()
}

func (*ArticleTagArticleBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return articletag.HasArticleWith(entx.CombinePredicates(predicates...))
}

func (b *ArticleTagArticleBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*ArticleTagQuery)
	if !ok {
		panic(fmt.Sprintf("ArticleTagArticleBridge.Include expect *ArticleTagQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.ArticleTagQuery.WithArticle(func(q *ent.ArticleQuery) {
		cq(&ArticleQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Article](handlers...))})
	})
	return adapter
}
// DepartmentEmployeesBridge (O2M) left=Department, right=Employee
type DepartmentEmployeesBridge struct {
  entx.BaseBridge
}

func newDepartmentEmployeesBridge(
  left entx.Node, right entx.Node,
) *DepartmentEmployeesBridge {
  return &DepartmentEmployeesBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "department_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*DepartmentEmployeesBridge) Filter() func(*sql.Selector) {
  return department.HasEmployees()
}

func (*DepartmentEmployeesBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return department.HasEmployeesWith(entx.CombinePredicates(predicates...))
}

func (b *DepartmentEmployeesBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*DepartmentQuery)
	if !ok {
		panic(fmt.Sprintf("DepartmentEmployeesBridge.Include expect *DepartmentQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.DepartmentQuery.WithEmployees(func(q *ent.EmployeeQuery) {
		cq(&EmployeeQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Employee](handlers...))})
	})
	return adapter
}
// EmployeeDepartmentBridge (M2O) left=Employee, right=Department
type EmployeeDepartmentBridge struct {
  entx.BaseBridge
}

func newEmployeeDepartmentBridge(
  left entx.Node, right entx.Node,
) *EmployeeDepartmentBridge {
  return &EmployeeDepartmentBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "department_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*EmployeeDepartmentBridge) Filter() func(*sql.Selector) {
  return employee.HasDepartment()
}

func (*EmployeeDepartmentBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return employee.HasDepartmentWith(entx.CombinePredicates(predicates...))
}

func (b *EmployeeDepartmentBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*EmployeeQuery)
	if !ok {
		panic(fmt.Sprintf("EmployeeDepartmentBridge.Include expect *EmployeeQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.EmployeeQuery.WithDepartment(func(q *ent.DepartmentQuery) {
		cq(&DepartmentQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Department](handlers...))})
	})
	return adapter
}
// EmployeeManagerBridge (M2O) left=Employee, right=Employee
type EmployeeManagerBridge struct {
  entx.BaseBridge
}

func newEmployeeManagerBridge(
  left entx.Node, right entx.Node,
) *EmployeeManagerBridge {
  return &EmployeeManagerBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "id",
        FinalRightField: "manager_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*EmployeeManagerBridge) Filter() func(*sql.Selector) {
  return employee.HasManager()
}

func (*EmployeeManagerBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return employee.HasManagerWith(entx.CombinePredicates(predicates...))
}

func (b *EmployeeManagerBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*EmployeeQuery)
	if !ok {
		panic(fmt.Sprintf("EmployeeManagerBridge.Include expect *EmployeeQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.EmployeeQuery.WithManager(func(q *ent.EmployeeQuery) {
		cq(&EmployeeQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Employee](handlers...))})
	})
	return adapter
}
// EmployeeReportsBridge (O2M) left=Employee, right=Employee
type EmployeeReportsBridge struct {
  entx.BaseBridge
}

func newEmployeeReportsBridge(
  left entx.Node, right entx.Node,
) *EmployeeReportsBridge {
  return &EmployeeReportsBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "manager_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*EmployeeReportsBridge) Filter() func(*sql.Selector) {
  return employee.HasReports()
}

func (*EmployeeReportsBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return employee.HasReportsWith(entx.CombinePredicates(predicates...))
}

func (b *EmployeeReportsBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*EmployeeQuery)
	if !ok {
		panic(fmt.Sprintf("EmployeeReportsBridge.Include expect *EmployeeQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.EmployeeQuery.WithReports(func(q *ent.EmployeeQuery) {
		cq(&EmployeeQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Employee](handlers...))})
	})
	return adapter
}
// TagArticlesBridge (M2M) left=Tag, right=Article
type TagArticlesBridge struct {
  entx.BaseBridge
}

func newTagArticlesBridge(
  left entx.Node, right entx.Node,
) *TagArticlesBridge {
  return &TagArticlesBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2M,
        FinalLeftField:  "id",
        FinalRightField: "id",
        PivotTable:      "article_tags",
        PivotLeftField:  "tag_id",
        PivotRightField: "article_id",
      },
    ),
  }
}

func (*TagArticlesBridge) Filter() func(*sql.Selector) {
  return tag.HasArticles()
}

func (*TagArticlesBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return tag.HasArticlesWith(entx.CombinePredicates(predicates...))
}

func (b *TagArticlesBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*TagQuery)
	if !ok {
		panic(fmt.Sprintf("TagArticlesBridge.Include expect *TagQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.TagQuery.WithArticles(func(q *ent.ArticleQuery) {
		cq(&ArticleQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Article](handlers...))})
	})
	return adapter
}
// ArticleTagsBridge (M2M) left=Article, right=Tag
type ArticleTagsBridge struct {
  entx.BaseBridge
}

func newArticleTagsBridge(
  left entx.Node, right entx.Node,
) *ArticleTagsBridge {
  return &ArticleTagsBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2M,
        FinalLeftField:  "id",
        FinalRightField: "id",
        PivotTable:      "article_tags",
        PivotLeftField:  "article_id",
        PivotRightField: "tag_id",
      },
    ),
  }
}

func (*ArticleTagsBridge) Filter() func(*sql.Selector) {
  return article.HasTags()
}

func (*ArticleTagsBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return article.HasTagsWith(entx.CombinePredicates(predicates...))
}

func (b *ArticleTagsBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*ArticleQuery)
	if !ok {
		panic(fmt.Sprintf("ArticleTagsBridge.Include expect *ArticleQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.ArticleQuery.WithTags(func(q *ent.TagQuery) {
		cq(&TagQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Tag](handlers...))})
	})
	return adapter
}
// TagArticleTagBridge (O2M) left=Tag, right=ArticleTag
type TagArticleTagBridge struct {
  entx.BaseBridge
}

func newTagArticleTagBridge(
  left entx.Node, right entx.Node,
) *TagArticleTagBridge {
  return &TagArticleTagBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "tag_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*TagArticleTagBridge) Filter() func(*sql.Selector) {
  return tag.HasArticleTag()
}

func (*TagArticleTagBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return tag.HasArticleTagWith(entx.CombinePredicates(predicates...))
}

func (b *TagArticleTagBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*TagQuery)
	if !ok {
		panic(fmt.Sprintf("TagArticleTagBridge.Include expect *TagQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.TagQuery.WithArticleTag(func(q *ent.ArticleTagQuery) {
		cq(&ArticleTagQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.ArticleTag](handlers...))})
	})
	return adapter
}
// ArticleTagTagBridge (M2O) left=ArticleTag, right=Tag
type ArticleTagTagBridge struct {
  entx.BaseBridge
}

func newArticleTagTagBridge(
  left entx.Node, right entx.Node,
) *ArticleTagTagBridge {
  return &ArticleTagTagBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "tag_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*ArticleTagTagBridge) Filter() func(*sql.Selector) {
  return articletag.HasTag()
}

func (*ArticleTagTagBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return articletag.HasTagWith(entx.CombinePredicates(predicates...))
}

func (b *ArticleTagTagBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*ArticleTagQuery)
	if !ok {
		panic(fmt.Sprintf("ArticleTagTagBridge.Include expect *ArticleTagQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.ArticleTagQuery.WithTag(func(q *ent.TagQuery) {
		cq(&TagQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Tag](handlers...))})
	})
	return adapter
}
// UserArticlesBridge (O2M) left=User, right=Article
type UserArticlesBridge struct {
  entx.BaseBridge
}

func newUserArticlesBridge(
  left entx.Node, right entx.Node,
) *UserArticlesBridge {
  return &UserArticlesBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "user_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*UserArticlesBridge) Filter() func(*sql.Selector) {
  return user.HasArticles()
}

func (*UserArticlesBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return user.HasArticlesWith(entx.CombinePredicates(predicates...))
}

func (b *UserArticlesBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*UserQuery)
	if !ok {
		panic(fmt.Sprintf("UserArticlesBridge.Include expect *UserQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.UserQuery.WithArticles(func(q *ent.ArticleQuery) {
		cq(&ArticleQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Article](handlers...))})
	})
	return adapter
}
// ArticleAuthorBridge (M2O) left=Article, right=User
type ArticleAuthorBridge struct {
  entx.BaseBridge
}

func newArticleAuthorBridge(
  left entx.Node, right entx.Node,
) *ArticleAuthorBridge {
  return &ArticleAuthorBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "user_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*ArticleAuthorBridge) Filter() func(*sql.Selector) {
  return article.HasAuthor()
}

func (*ArticleAuthorBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return article.HasAuthorWith(entx.CombinePredicates(predicates...))
}

func (b *ArticleAuthorBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*ArticleQuery)
	if !ok {
		panic(fmt.Sprintf("ArticleAuthorBridge.Include expect *ArticleQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.ArticleQuery.WithAuthor(func(q *ent.UserQuery) {
		cq(&UserQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.User](handlers...))})
	})
	return adapter
}
// UserCommentsBridge (O2M) left=User, right=Comment
type UserCommentsBridge struct {
  entx.BaseBridge
}

func newUserCommentsBridge(
  left entx.Node, right entx.Node,
) *UserCommentsBridge {
  return &UserCommentsBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2M,
        FinalLeftField:  "id",
        FinalRightField: "user_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*UserCommentsBridge) Filter() func(*sql.Selector) {
  return user.HasComments()
}

func (*UserCommentsBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return user.HasCommentsWith(entx.CombinePredicates(predicates...))
}

func (b *UserCommentsBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*UserQuery)
	if !ok {
		panic(fmt.Sprintf("UserCommentsBridge.Include expect *UserQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.UserQuery.WithComments(func(q *ent.CommentQuery) {
		cq(&CommentQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Comment](handlers...))})
	})
	return adapter
}
// CommentUserBridge (M2O) left=Comment, right=User
type CommentUserBridge struct {
  entx.BaseBridge
}

func newCommentUserBridge(
  left entx.Node, right entx.Node,
) *CommentUserBridge {
  return &CommentUserBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.M2O,
        FinalLeftField:  "user_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*CommentUserBridge) Filter() func(*sql.Selector) {
  return comment.HasUser()
}

func (*CommentUserBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return comment.HasUserWith(entx.CombinePredicates(predicates...))
}

func (b *CommentUserBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*CommentQuery)
	if !ok {
		panic(fmt.Sprintf("CommentUserBridge.Include expect *CommentQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.CommentQuery.WithUser(func(q *ent.UserQuery) {
		cq(&UserQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.User](handlers...))})
	})
	return adapter
}
// UserEmployeeBridge (O2O) left=User, right=Employee
type UserEmployeeBridge struct {
  entx.BaseBridge
}

func newUserEmployeeBridge(
  left entx.Node, right entx.Node,
) *UserEmployeeBridge {
  return &UserEmployeeBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2O,
        FinalLeftField:  "id",
        FinalRightField: "user_id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*UserEmployeeBridge) Filter() func(*sql.Selector) {
  return user.HasEmployee()
}

func (*UserEmployeeBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return user.HasEmployeeWith(entx.CombinePredicates(predicates...))
}

func (b *UserEmployeeBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*UserQuery)
	if !ok {
		panic(fmt.Sprintf("UserEmployeeBridge.Include expect *UserQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.UserQuery.WithEmployee(func(q *ent.EmployeeQuery) {
		cq(&EmployeeQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.Employee](handlers...))})
	})
	return adapter
}
// EmployeeUserBridge (O2O) left=Employee, right=User
type EmployeeUserBridge struct {
  entx.BaseBridge
}

func newEmployeeUserBridge(
  left entx.Node, right entx.Node,
) *EmployeeUserBridge {
  return &EmployeeUserBridge{
    BaseBridge: entx.NewBaseBridge(
      left,
      right,
      nil,
      entx.RelationInfos{
        RelType:         sqlgraph.O2O,
        FinalLeftField:  "user_id",
        FinalRightField: "id",
        PivotTable:      "",
        PivotLeftField:  "",
        PivotRightField: "",
      },
    ),
  }
}

func (*EmployeeUserBridge) Filter() func(*sql.Selector) {
  return employee.HasUser()
}

func (*EmployeeUserBridge) FilterWith(predicates ...func(*sql.Selector)) func(*sql.Selector) {
  return employee.HasUserWith(entx.CombinePredicates(predicates...))
}

func (b *EmployeeUserBridge) Include(pq entx.Query, cq func(entx.Query), handlers ...entx.EntityHandler) entx.Query {
	adapter, ok := pq.(*EmployeeQuery)
	if !ok {
		panic(fmt.Sprintf("EmployeeUserBridge.Include expect *EmployeeQuery as Query, got: %s", reflect.TypeOf(pq)))
	}

	adapter.EmployeeQuery.WithUser(func(q *ent.UserQuery) {
		cq(&UserQuery{q.AppendInterceptors(entx.ToInterceptor[*ent.User](handlers...))})
	})
	return adapter
}

var Graph = BuildGraph()

func BuildGraph() map[string]entx.Node {
  var articleNode = newArticleNode()
  var articleTagNode = newArticleTagNode()
  var commentNode = newCommentNode()
  var departmentNode = newDepartmentNode()
  var employeeNode = newEmployeeNode()
  var tagNode = newTagNode()
  var userNode = newUserNode()
  
  var articleCommentsBridge = newArticleCommentsBridge(articleNode, commentNode)
  articleNode.SetBridge("comments", articleCommentsBridge)
  var commentArticleBridge = newCommentArticleBridge(commentNode, articleNode)
  commentNode.SetBridge("article", commentArticleBridge)
  articleCommentsBridge.SetInverse(commentArticleBridge)
  commentArticleBridge.SetInverse(articleCommentsBridge)
  
  var articleArticleTagBridge = newArticleArticleTagBridge(articleNode, articleTagNode)
  articleNode.SetBridge("article_tag", articleArticleTagBridge)
  var articleTagArticleBridge = newArticleTagArticleBridge(articleTagNode, articleNode)
  articleTagNode.SetBridge("article", articleTagArticleBridge)
  articleArticleTagBridge.SetInverse(articleTagArticleBridge)
  articleTagArticleBridge.SetInverse(articleArticleTagBridge)
  
  var departmentEmployeesBridge = newDepartmentEmployeesBridge(departmentNode, employeeNode)
  departmentNode.SetBridge("employees", departmentEmployeesBridge)
  var employeeDepartmentBridge = newEmployeeDepartmentBridge(employeeNode, departmentNode)
  employeeNode.SetBridge("department", employeeDepartmentBridge)
  departmentEmployeesBridge.SetInverse(employeeDepartmentBridge)
  employeeDepartmentBridge.SetInverse(departmentEmployeesBridge)
  
  var employeeManagerBridge = newEmployeeManagerBridge(employeeNode, employeeNode)
  employeeNode.SetBridge("manager", employeeManagerBridge)
  
  var employeeReportsBridge = newEmployeeReportsBridge(employeeNode, employeeNode)
  employeeNode.SetBridge("reports", employeeReportsBridge)
  
  var tagArticlesBridge = newTagArticlesBridge(tagNode, articleNode)
  tagNode.SetBridge("articles", tagArticlesBridge)
  var articleTagsBridge = newArticleTagsBridge(articleNode, tagNode)
  articleNode.SetBridge("tags", articleTagsBridge)
  tagArticlesBridge.SetInverse(articleTagsBridge)
  articleTagsBridge.SetInverse(tagArticlesBridge)
  
  var tagArticleTagBridge = newTagArticleTagBridge(tagNode, articleTagNode)
  tagNode.SetBridge("article_tag", tagArticleTagBridge)
  var articleTagTagBridge = newArticleTagTagBridge(articleTagNode, tagNode)
  articleTagNode.SetBridge("tag", articleTagTagBridge)
  tagArticleTagBridge.SetInverse(articleTagTagBridge)
  articleTagTagBridge.SetInverse(tagArticleTagBridge)
  
  var userArticlesBridge = newUserArticlesBridge(userNode, articleNode)
  userNode.SetBridge("articles", userArticlesBridge)
  var articleAuthorBridge = newArticleAuthorBridge(articleNode, userNode)
  articleNode.SetBridge("author", articleAuthorBridge)
  userArticlesBridge.SetInverse(articleAuthorBridge)
  articleAuthorBridge.SetInverse(userArticlesBridge)
  
  var userCommentsBridge = newUserCommentsBridge(userNode, commentNode)
  userNode.SetBridge("comments", userCommentsBridge)
  var commentUserBridge = newCommentUserBridge(commentNode, userNode)
  commentNode.SetBridge("user", commentUserBridge)
  userCommentsBridge.SetInverse(commentUserBridge)
  commentUserBridge.SetInverse(userCommentsBridge)
  
  var userEmployeeBridge = newUserEmployeeBridge(userNode, employeeNode)
  userNode.SetBridge("employee", userEmployeeBridge)
  var employeeUserBridge = newEmployeeUserBridge(employeeNode, userNode)
  employeeNode.SetBridge("user", employeeUserBridge)
  userEmployeeBridge.SetInverse(employeeUserBridge)
  employeeUserBridge.SetInverse(userEmployeeBridge)
  
  return map[string]entx.Node{
    "Article": articleNode,
    "ArticleTag": articleTagNode,
    "Comment": commentNode,
    "Department": departmentNode,
    "Employee": employeeNode,
    "Tag": tagNode,
    "User": userNode,
  }
}
