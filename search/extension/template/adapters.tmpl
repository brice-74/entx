{{- define "adapters" -}}
{{- $searchImportName := searchImportName -}}

// Code generated by entx, DO NOT EDIT.

package entx

import (
   "errors"
   "context"
   "fmt"

   "{{ searchImportPath }}"

   stdsql "database/sql"

   "entgo.io/ent/dialect/sql"

   "{{ .Package }}"
)

type Client struct {
   *ent.Client
}

func NewClient(c *ent.Client) *Client {
   return &Client{c}
}

func (c *Client) Tx(ctx context.Context, opts *stdsql.TxOptions) ({{ $searchImportName }}.Transaction, {{ $searchImportName }}.Client, error) {
	tx, err := c.Client.BeginTx(ctx, opts)
	if err != nil {
		return nil, nil, err
	}

	return tx, NewClient(tx.Client()), nil
}

func (c *Client) GetEntityClient(n {{ $searchImportName }}.Node) ({{ $searchImportName }}.EntityClient, error) {
   if n == nil {
      return nil, errors.New("node is nil")
   }

   switch nodeName := n.Name(); nodeName {
   {{- range .Nodes -}}
   {{- if isNodeInclude . }}
   case "{{ .Name }}":
      return &{{ .ClientName }}{ {{ .ClientName }}: c.Client.{{ .Name }}}, nil
   {{- end }}
   {{- end }}
   default:
      return nil, fmt.Errorf("node named \"%s\" hasn't client", nodeName)
   }
}

func (c *Client) MustGetEntityClient(n {{ $searchImportName }}.Node) {{ $searchImportName }}.EntityClient {
   ec, err := c.GetEntityClient(n)
   if err != nil {
      panic(err)
   }
   return ec
}

{{- range .Nodes }}
{{- if isNodeInclude . }}
type {{ .ClientName }} struct {
   *ent.{{ .ClientName }}
}

func (c *{{ .ClientName }}) Query()  {{ $searchImportName }}.Query {
   return &{{ .QueryName }}{c.{{ .ClientName }}.Query()}
}

type {{ .QueryName }} struct {
   *ent.{{ .QueryName }}
}

func (q *{{ .QueryName }}) Predicate(preds ...func(s *sql.Selector)) {{ $searchImportName }}.Query {
   q.{{ .QueryName }}.Modify(preds...)
   return q
}

func (q *{{ .QueryName }}) Select(columns ...string) {{ $searchImportName }}.Query {
   q.{{ .QueryName }}.Select(columns...)
   return q
}

func (q *{{ .QueryName }}) All(ctx context.Context) ([]{{ $searchImportName }}.Entity, error) {
   entities, err := q.{{ .QueryName }}.All(ctx)
   if err != nil {
      return nil, err
   }

   return {{ $searchImportName }}.ToEntitySlice(entities), nil
}
{{- end }}
{{- end }}

{{- end }}